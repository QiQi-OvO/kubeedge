# Device Data And Usability Enhancement 

## Motivation
1. Reduce the difficulty for developers to develop customized mapper.
2. Add data plane implementation for DMI, provide interface for pushing data, pulling data, and storing data.
3. The current mappers-go project has become outdated, and these expired contents make the repository confusion.With the update of DMI, mappers also need to change frequently, this proposal can adapt to the iteration of DMI.
4. Provide reference ideas for the development of mappers in other languages.
### Goals
- Provide mapper-generator framework in the staging directory.
- Provide data processing capabilities for mapper.

### Non-goals
- To provide frameworks for other programming languages.
- To provide monitoring metrics.

## Proposal
This proposal provides the mapper-generator which integrates the device management interface and optimizes the device management capability of KubeEdge. It is the goal of the mapper-generator that builds a cloud native device twin management plugin which covers device management, device operation and device data.

### Architecture

<img src="../images/mapper/mapper-generator-architecture.jpg">

### User-facing change
1. Using DMI to communicate between EdgeCore and Mapper.
2. Mapper framework provide a data push interface for pushing to edge applications, the destination rule are defined through CRD.
3. Mapper framework provide a dabase interface that can save data to database and get data from database, the persistence rule are defined through `config.yaml`.
4. Mapper framework provide the REST API, these APIs can access devices to obtain data or connect to database get more data. API does not support changing device property, because this will result in Inconsistent messages between cloud and edge.
5. Mapper framework provide device driver interfaces to simplify mapper development.
6. Mapper-generator provide `Makefile` that can generate a mapper framework with one command.


## Design Details

### Generator

<img src="../images/mapper/mapper-device-management.jpg">

- DMI v1alpha1 API and Panel can be implemented by the generator,Developers only need to focus on device drivers.
- The red part in generator (Driver) means that developers need to implement it. The red part in Mapper (like API.ReportState GetDeviceStatus) is currently not implemented and is part of the subsequent DMI update plan.
- Define interfaces `DevPanel` to manage devices, new interfaces will be added when features are added.
```go
// DevPanel defined operations on devices, manage the lifecycle of devices
type DevPanel interface {
	// DevStart start device to collect/push/save data to edgecore/app/database
	DevStart()
	// DevInit get device info by dmi interface
	DevInit(cfg *config.Config) error
	// UpdateDev update device's config and restart the device
	UpdateDev(model *common.DeviceModel, device *common.DeviceInstance, protocol *common.Protocol)
	// UpdateDevTwins update device twin's config and restart the device
	UpdateDevTwins(deviceID string, twins []common.Twin) error
	// DealDeviceTwinGet get device's twin data
	DealDeviceTwinGet(deviceID string, twinName string) (interface{}, error)
	// GetDevice get device's instance info
	GetDevice(deviceID string) (interface{}, error)
	// RemoveDevice stop device and remove device
	RemoveDevice(deviceID string) error
	// GetModel get model's info
	GetModel(modelName string) (common.DeviceModel, error)
	// UpdateModel update model in map only
	UpdateModel(model *common.DeviceModel)
	// RemoveModel remove model in map only
	RemoveModel(modelName string)
	// GetTwinResult get device's property value and datatype
	GetTwinResult(deviceID string, twinName string) (string, string, error)
}
```



### Data Stream

<img src="../images/mapper/mapper-device-data.jpg">

#### Data Normalization
In order to transfer data between interface modules, standardization of data is necessary. These data should contain the necessary information generated by the data. In addition, developers can also assemble customized data structures from standardized data when implementing their own interfaces. The standardized data definition is as follows:
```go
// DataModel defined standard data model for transferring data between interfaces
type DataModel struct {
    // DeviceName name of the device that generated the data
	DeviceName   string
    // PropertyName 
	PropertyName string

    // Value string formatted data
	Value string
    // Type the actual type of data
	Type  string

    // TimeStamp time of data generation
	TimeStamp int64
}
```
 


#### Push
The data push module can push property values of devices to edge reachable apps for consumption according to destination rules that defined by CRD. The current CRD definitions of Device and DeviceModel cannot meet the new features requirements of DMI, to meet the new requirements and be compatible with the original definitions, the DeviceInstance CRD `DeviceSpec.PropertyVisitors.VisitorConfig` add new fields `PushMethod` as follow:

```go
// At least one of its members must be specified.
type VisitorConfig struct {
	// Opcua represents a set of additional visitor config fields of opc-ua protocol.
	// +optional
	OpcUA *VisitorConfigOPCUA `json:"opcua,omitempty"`
	// Modbus represents a set of additional visitor config fields of modbus protocol.
	// +optional
	Modbus *VisitorConfigModbus `json:"modbus,omitempty"`
	// Bluetooth represents a set of additional visitor config fields of bluetooth protocol.
	// +optional
	Bluetooth *VisitorConfigBluetooth `json:"bluetooth,omitempty"`
	// CustomizedProtocol represents a set of visitor config fields of bluetooth protocol.
	// +optional
	CustomizedProtocol *VisitorConfigCustomized `json:"customizedProtocol,omitempty"`
	// PushMethod represents the protocol used to push data,
	// please ensure that the mapper can access the destination address.
	// +optional
	PushMethod *VisitorPushMethod `json:"pushMethod,omitempty"`
}

type VisitorPushMethod struct {
	// HTTP Push method configuration for http
	// +optional
	HTTP *PushMethodHTTP `json:"http,omitempty"`
	// CustomizedProtocol configuration for customized push method
	// +optional
	CustomizedProtocol *VisitorConfigCustomized `json:"customizedProtocol,omitempty"`
	// MQTT Push method configuration for mqtt
	// +optional
	MQTT *PushMethodMQTT `json:"mqtt,omitempty"`
}

type PushMethodHTTP struct {
	// +optional
	HostName string `json:"hostName,omitempty"`
	// +optional
	Port int64 `json:"port,omitempty"`
	// +optional
	RequestPath string `json:"requestPath,omitempty"`
	// +optional
	Timeout int64 `json:"timeout,omitempty"`
}

type PushMethodMQTT struct {
	// broker address, like mqtt://127.0.0.1:1883
	// +optional
	Address string `json:"address,omitempty"`
	// publish topic for mqtt
	// +optional
	Topic string `json:"topic,omitempty"`
	// qos of mqtt publish param
	// +optional
	QoS int32 `json:"qos,omitempty"`
	// Is the message retained
	// +optional
	Retained bool `json:"retained,omitempty"`
}
```
In the current CRD definition, MQTT and HTTP protocols are supported, and the cycle(default 1s) is defined by the `DevicePropertyVisitor.ReportCycle`. The mapper framework has defined interfaces for data push:
```go
// DataPanel defined push method, parse the push operation in CRD and execute it
type DataPanel interface {
	// InitPushMethod initialization operation before push
	InitPushMethod() error
	// Push implement push operation
	Push(data *common.DataModel)
}
```
When mapper is executed, it will automatically parse the value of the `pushMethod` field and execute the `DataPanel` interface to push data.  
In the future, the types of protocols will be added and custom protocols will be supported. `DataPanel` interface will add more interfaces to ensure data security.

#### DataBase
The database module can store device data to a local database, the module supports developers to implement interfaces to connect with different databases. The database interface is defined as follows:
```go
// DataBaseClient defined database interface, save data and provide data to REST API
type DataBaseClient interface {
    // InitDbClient database init and connection
	InitDbClient() error
    // CloseSession database disconnection
	CloseSession()

    // AddData add device data to db
	AddData(data *common.DataModel)

    // TODO Add Query Interface
	GetDataBy_XXX(XXX interface{}) ([]*common.DataModel, error)

    // TODO Add Delete Interface
	DeleteDataBy_XXX(XXX interface{}) error
}
```
The definition of database query and deletion interfaces is currently not yet complete, these interfaces are designed to be called by HTTP callback functions, which support local database operations.


#### Pull
The HTTP server was created to provide API services. It supports  directly obtaining device data from the device, querying device metadata, and accessing database through a database interface.
The server supports security features and provides three access modes:
| CA certificate | Server certificate | Server key | Mode|
| --- | --- | --- | ---|
| √ | √ | √ | MTLS |
| × | √ | √ | TLS |
| × | × | × | Insecurity |

The URLs listed below are given in the form of local IP. You can use these services from any network accessible to mapper.

Port `7777` is enabled by default.

`deviceInstance-ID` according to your own CRD definition
`propertyName` according to your own CRD definition

#### Ping
1. Detect whether the RESTful service starts normally  
   Method: **GET**  
   Url: https://127.0.0.1:7777/api/v1/ping  
   Response:
   ```json
   {
    "apiVersion": "v1",
    "statusCode": 200,
    "timeStamp": "2023-08-18T09:57:29+08:00",
    "Message": "This is v1 API, the server is running normally."
    }
   ```
#### Device Data
1. Get device's Data  
   Method=**GET**  
   Url: https://127.0.0.1:7777/api/v1/device/deviceInstance-ID/propertyName
   Response:
   ```json
   {
    "apiVersion": "v1",
    "statusCode": 200,
    "timeStamp": "2023-08-18T09:57:35+08:00",
    "Data": {
        "DeviceName": "deviceInstance-ID",
        "PropertyName": "propertyName",
        "Value": "data",
        "Type": "dataType",
        "CollectTimeStamp": 1692323855044
        }
    }
   ```
#### Device MetaData
1. Get device's Model  
   Method=**GET**  
   Url: https://127.0.0.1:7777/api/v1/meta/model/deviceInstance-ID  
   Response:
   ```json
   {
    "apiVersion": "v1",
    "statusCode": 200,
    "timeStamp": "2023-08-18T09:57:37+08:00",
    "name": "model-name",
    "properties": [
        {
            "name": "propertyName-1",
            "dataType": "property data type",
            "description": "property description",
            "accessMode": "ReadWrite",
            "defaultValue": 100
        },
        ...
        ]
    }
   ```

#### DataBase
The API for operating the database is currently not defined.

## Implementation plan
- Interface and API Improvement
  - Push Interface Improvement
  - DataBase Interface Imporvement
  - REST API Imporvement
- Database implementation
  - Time series database adaptation
  - K/V database adaptation
- Alpha
  - developer documentation
  - demo for mapper with DMI
- Beta: TBD
- GA: TBD
